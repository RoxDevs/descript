use std::str::FromStr;
use crate::ast::expr::{Expr, Op};
use crate::lexer::Token;
use crate::ast::stmt::{KeyWord, Stmt, Arg};

grammar<'input>;

pub Expr: Box<Expr> = { // (1)
    #[precedence(level = "2")] #[assoc(side="left")]
    "("? <e:Expr> ")"? " " <o:ExprOp> " " "("? <f:Factor> ")"? => Box::new(Expr::Op(e, o, f)), // (2)
    #[precedence(level = "1")]
    Factor,
};

ExprOp: Op = { // (3)
    "+" => Op::Add,
    "-" => Op::Sub,
};

Factor: Box<Expr> = {
    <f:Factor> " " <o:FactorOp> " " <t:Term> => Box::new(Expr::Op(f, o, t)),
    Term,
};

FactorOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Num(<>)),
    // "(" <Expr> ")"
};

Num: i32 = {
    <n:int_tok> => i32::from_str(n).unwrap()
};

pub String: String = {
    <s:str_tok> => {
        let length = s.len();
        let inner = &s[1..length-1];
        inner.to_string()
    }
}

Keyword: KeyWord = {
    "echo" => KeyWord::Echo
}

Arg: Arg = {
    Num => Arg::Num(<>),
    String => Arg::Str(<>)
}

Args: Vec<Arg> = {
    (<Arg> " ")* => <>,
    Arg => vec![<>],
}

pub Stmt: Stmt = {
    <kw:Keyword> " " <v:Args> => {
        Stmt {
            kw,
            args: v
        }
    }
}

extern {
    type Location = usize;
    type Error = crate::lexer::LexicalError;

    enum Token<'input> {
        "+" => Token::OpAdd,
        "-" => Token::OpSub,
        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "(" => Token::ParenBegin,
        ")" => Token::ParenEnd,
        " " => Token::ExpectedWS,
        int_tok => Token::Int(<&'input str>),
        str_tok => Token::Str(<&'input str>),
        "echo" => Token::KwEcho,
        quote => Token::Quote
    }
}
